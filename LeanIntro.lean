-- Lean. Очень краткое введение
-- ============================

-- Два дефиса (как в начале этой строки) обозначают комментарий: они и всё,
-- что написано до конца строки не видно программе.
-- Многострочные комментарии заключаются между /- и -/ (см. ниже).

-- Полная документация: https://lean-lang.org/learn.
-- Там же есть список учебников.

-- Программа Lean состоит из деклараций, записанных в файл с расширением '.lean'
-- (как этот).

-- Типы в Lean сами являются элементами универсумов типов, которые обозначаются Sort u.
-- Нижний Sort 0 обозначается Prop, а более высокие Sort u+1 как Type u.

-- Lean определяет несколько базовых типов, таких как строки, алфавитные символы и пр.
-- Единственный встроенный сложный тип это тип функций.

-- Ядро Lean:
--   1) средства для определения функций и работы с ними,
--   2) средства для определения типов,
--   3) универсумы типов.


-- Определения новых типов
-- =======================

-- Новые типы определяются инструкцией inductive.
-- Тип определяется конструкторами, то есть, функциями(?), конструирующими термы
-- определяемого типа.

-- Например:
-- Тип истинностных значений:
#print Bool

inductive Bool₁ : Type where           -- декларация типа (он относится к универсуму Type)
  | true  : Bool₁                      -- конструкторы типа (в данном случае -- нуль-местные
  | false : Bool₁                      --                    функции)

inductive Bool₂ where
| true | false

-- Другой пример:
-- Тип натуральных чисел:
#print Nat

inductive Nat₁ : Type where
  | zero : Nat₁                        -- начальное число
  | succ : Nat₁ → Nat₁                 -- следующее число, одноместная функция

inductive Nat₂ : Type where
  | zero : Nat₂
  | succ (n : Nat₂) : Nat₂

inductive Nat₃ where
| zero | succ (n : Nat₃)

#check Nat.zero

#check zero
open Nat
#check zero


-- Как видно, конструкторы имеют тип в качестве области значения. То есть они
-- конструируют элементы типа.


-- Определения констант

def n : Nat := 5
def bb : Bool := true
#print bb

-- theorem - спец. тип def для типов Prop.
theorem t1 : 2 + 2 = 4 := rfl

-- Два типа из универсума Prop:
#print False

inductive False₁ : Prop where

#print True

inductive True₁ : Prop where
| intro : True₁

#print trivial



-- Определения функций
-- ===================

/- Тип функций может записываться многими способами:

   (x : α) → β  или α → β                   - основной способ
   ∀ (x : α), β
   ∀ x, β
   (x y : α) → β или α → α → β
   (x : α) → (y : β) → γ  или α → β → γ
   ∀ (x : α) (y : β), γ
   ∀ x y, γ

   Термы этого типа (то есть функции) также записываются многими способами:
   λ (x : α) => b                            - основной способ
   fun (x : α) => b
   λ x => b
   λ (x y : α) => b

   λ/fun -- это конструктор функций

   Применение функции к аргументам, т.е. f(a,b), записывается как f a b.

-/


-- Функции определяются двумя способами.

-- Первый способ определения функций --- применением конструктора функций,
-- встроенного в Lean:

def f1  : Nat → Nat := λ (n : Nat) => Nat.succ (Nat.succ n)

def f1' : Nat → Nat := λ (n : Nat) => .succ (.succ n)

def f2 := fun (n : Nat) => succ (succ n)       -- иногда тип можно не декларировать
def f3 := λ n => succ (succ n)
def f4 := λ n => n + 2


-- В другом способе указывается действие функции на все конструкторы её аргументов.
-- Например, определим сложение чисел:

def add₁ : Nat → Nat → Nat             -- Сначала декларируется тип функции.
| zero,   zero   => zero               -- Затем указывается значение на всех возможных
| zero,   succ n => succ n             -- конструкторах типа Nat
| succ n, zero   => succ n
| succ n, succ m => succ (add₁ n (succ m))

-- Строго говоря, в определении могут стоять не конструкторы, а шаблоны (patterns).
-- Например, шаблон _ обозначает "неважно какое значение", а любой идентификатор,
-- не являющийся конструктором, считается переменной.
-- Поэтому определение выше можно было бы записать и так:

def add₂ : Nat → Nat → Nat
| zero,   n      => n               -- здесь n -- переменная
| succ n, zero   => succ n
| succ n, succ m => succ (add₂ n (succ m))

-- Или даже так:
def add₃ : Nat → Nat → Nat
| zero, n => n
| succ n, m => succ (add₃ n m)

def add₄ : Nat → Nat → Nat
| 0, n => n
| n + 1, m => (add₃ n m) + 1

#print Nat.add

-- Ещё пример функции.
-- Функция f = x + 2
def f : Nat → Nat
| 0 => 2
| n + 1 => n + 3

-- В данном конкретном случае можно было проще:
def f'  : Nat → Nat | n => n + 2
def f'' : Nat → Nat := fun n => n + 2

-- Ещё немного определений

def a := f zero               -- В данном случае не обязательно декларировать a : Nat и b : Nat.
def b := f (succ zero)        -- Lean сам определит тип a и b.


open Bool

-- Ещё функция:
def le : Nat → Nat → Bool
| zero, _ => true
| succ _, zero => false
| succ n, succ m => le n m

notation x " ≤' " y => le x y

-- Аргумент функции может быть неявным. Тогда он записывается в фигурных скобках:
-- {x : α} → β
-- ∀ {x} → β
-- Неявные аргументы могут не употребляться при применении функции.
-- Тогда Lean должен вычислить их сам.

-- Например, рассмотрим полиморфную функцию (т.е. ту, которую можно применять к
-- разным типам):
def if_then_else : {α : Type} → Bool → α → α → α
| _, true,  x, _ => x
| _, false, _, y => y

notation "if₁ " cond " then " x " else " y
  => if_then_else cond x y

-- Аргумент α является неявным и его можно не указывать:

example : Nat := if₁ (a ≤' b) then 0 else 1

-- Здесь α = Nat, но оно не указано -- Lean его вычисляет из типов 0 и 1

-- Ещё примеры скрытых аргументов

#print id

def id₁ : (α : Sort u) → α → α           -- Аргумент α явно указан.
| α, x => x

def id₂.{u} : (α : Sort u) → α → α
| _, x => x                            -- Но Lean может его вычислить.

def id₃ {α : Sort u} : α → α          -- Поэтому можно сделать его неявным.
| x => x

def id₄ : α → α                 -- Или даже так
| x => x

#print id₄


-- функции могут быть аргументами функций

def comp (f : α → β) (g : β → γ) : α → γ := λ x => g (f x)
def comp' (f : α → β) (g : β → γ) : α → γ := g ∘ f


-- Из конструированных термов (на самом деле, шаблонов) можно извлекать информацию:
def «предыдущее» : Nat → Nat
| zero => zero
| succ n => n     -- n "извлечено" из succ n


-- Рассмотрим теперь пример функции в зависимый тип.
-- Пример будет находиться в отдельном пространстве имён ns1.

namespace ns1

  inductive «Страна» : Type where
    | «Япония» : «Страна»
    | «Буркина-Фасо» : «Страна»
  open «Страна»

  -- индексированный тип (см. ниже)
  -- Это зависимый тип (тип «Город» зависит от типа «Страна»).
  inductive «Город» : «Страна» → Type where
    | «Токио»        : «Город» «Япония»
    | «Саппоро»      : «Город» «Япония»
    | «Уагадугу»     : «Город» «Буркина-Фасо»
    | «Бобо-Диуласо» : «Город» «Буркина-Фасо»
  open «Город»

  def «столица» : (x : «Страна») → «Город» x   -- как видно, тип значения зависит от аргумента
  | «Япония» => «Токио»
  | «Буркина-Фасо» => «Уагадугу»

  -- другие способы записать эту функцию:

  def «столица'» : ∀ (x : «Страна»), «Город» x
    := «столица»

  def «столица''» : ∀ (x : _), «Город» x
    := «столица»

  def «столица'''» : ∀ x, «Город» x
    := «столица»

end ns1
